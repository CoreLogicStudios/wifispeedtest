<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Network Speed Test - Railway</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 600px;
            width: 100%;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2.5em;
            font-weight: 300;
        }

        .subtitle {
            opacity: 0.7;
            margin-bottom: 30px;
            font-size: 1.1em;
        }

        .speed-display {
            font-size: 4em;
            font-weight: bold;
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .unit {
            font-size: 0.4em;
            opacity: 0.8;
        }

        .test-info {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }

        .info-item {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            transition: all 0.3s ease;
        }

        .info-item:hover {
            background: rgba(255, 255, 255, 0.15);
        }

        .info-label {
            font-size: 0.9em;
            opacity: 0.8;
            margin-bottom: 5px;
        }

        .info-value {
            font-size: 1.5em;
            font-weight: bold;
        }

        .progress-container {
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 12px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d2ff, #3a7bd5);
            width: 0%;
            transition: width 0.5s ease;
            border-radius: 6px;
        }

        .progress-text {
            margin-top: 10px;
            font-size: 0.9em;
            opacity: 0.8;
        }

        .start-btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            border: none;
            color: white;
            font-size: 1.2em;
            padding: 15px 40px;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            font-weight: 600;
        }

        .start-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
            background: linear-gradient(45deg, #ff5252, #d84315);
        }

        .start-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            margin: 20px 0;
            font-size: 1.1em;
            opacity: 0.9;
            min-height: 1.5em;
        }

        .test-type {
            font-size: 1.4em;
            margin: 10px 0;
            font-weight: 500;
            min-height: 1.5em;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .testing {
            animation: pulse 1.5s infinite;
        }

        .results {
            display: none;
            margin-top: 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
        }

        .results.show {
            display: block;
        }

        .result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            font-size: 1.1em;
        }

        .result-item:last-child {
            border-bottom: none;
        }

        .result-label {
            font-weight: 500;
        }

        .result-value {
            font-weight: bold;
            font-size: 1.2em;
        }

        .settings {
            margin-top: 30px;
            text-align: left;
            background: rgba(255, 255, 255, 0.05);
            padding: 20px;
            border-radius: 15px;
        }

        .settings h3 {
            text-align: center;
            margin-bottom: 20px;
            font-size: 1.2em;
            opacity: 0.9;
        }

        .setting-item {
            margin: 15px 0;
        }

        .setting-item label {
            display: block;
            margin-bottom: 8px;
            font-size: 0.95em;
            font-weight: 500;
        }

        .setting-item select, .setting-item input {
            width: 100%;
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 1em;
        }

        .setting-item select option {
            background: #333;
            color: white;
        }

        .setting-item input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }

        .server-info {
            margin-top: 30px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            font-size: 0.9em;
        }

        .server-info div {
            margin: 5px 0;
        }

        .error {
            color: #ff6b6b;
            background: rgba(255, 107, 107, 0.1);
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
        }

        @media (max-width: 768px) {
            .container {
                padding: 30px 20px;
            }
            
            .speed-display {
                font-size: 3em;
            }
            
            .test-info {
                grid-template-columns: 1fr;
                gap: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Speed Test</h1>
        <div class="subtitle">Powered by Railway</div>
        
        <div class="speed-display" id="speedDisplay">
            0.00 <span class="unit">Mbps</span>
        </div>
        
        <div class="test-type" id="testType">Ready to Test</div>
        
        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Click START to begin</div>
        </div>
        
        <div class="status" id="status">Select your test settings and click START</div>
        
        <button class="start-btn" id="startBtn" onclick="startTest()">START TEST</button>
        
        <div class="test-info">
            <div class="info-item">
                <div class="info-label">Ping</div>
                <div class="info-value" id="pingValue">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Jitter</div>
                <div class="info-value" id="jitterValue">-</div>
            </div>
            <div class="info-item">
                <div class="info-label">Loss</div>
                <div class="info-value" id="lossValue">-</div>
            </div>
        </div>
        
        <div class="results" id="results">
            <h3 style="margin-bottom: 15px;">Test Results</h3>
            <div class="result-item">
                <span class="result-label">Download Speed:</span>
                <span class="result-value" id="downloadResult">- Mbps</span>
            </div>
            <div class="result-item">
                <span class="result-label">Upload Speed:</span>
                <span class="result-value" id="uploadResult">- Mbps</span>
            </div>
            <div class="result-item">
                <span class="result-label">Test Duration:</span>
                <span class="result-value" id="durationResult">- seconds</span>
            </div>
            <div class="result-item">
                <span class="result-label">Server:</span>
                <span class="result-value" id="serverResult">-</span>
            </div>
        </div>
        
        <div class="settings">
            <h3>Test Settings</h3>
            <div class="setting-item">
                <label for="testServer">Test Server:</label>
                <select id="testServer">
                    <option value="auto">Auto (Current Server)</option>
                    <option value="custom">Custom Server</option>
                </select>
            </div>
            <div class="setting-item" id="customServerDiv" style="display: none;">
                <label for="customServer">Custom Server URL:</label>
                <input type="text" id="customServer" placeholder="https://your-server.railway.app">
            </div>
            <div class="setting-item">
                <label for="testDuration">Test Duration:</label>
                <select id="testDuration">
                    <option value="10">10 seconds</option>
                    <option value="15" selected>15 seconds</option>
                    <option value="30">30 seconds</option>
                </select>
            </div>
            <div class="setting-item">
                <label for="connectionCount">Parallel Connections:</label>
                <select id="connectionCount">
                    <option value="4">4 connections</option>
                    <option value="6" selected>6 connections</option>
                    <option value="8">8 connections</option>
                </select>
            </div>
        </div>
        
        <div class="server-info">
            <div>Server: <span id="serverLocation">Detecting...</span></div>
            <div>Your IP: <span id="clientIP">Loading...</span></div>
            <div>Status: <span id="serverStatus">Checking...</span></div>
        </div>
    </div>

    <script>
        class RailwaySpeedTest {
            constructor() {
                this.isRunning = false;
                this.serverUrl = window.location.origin; // Use current domain
                this.results = {
                    download: 0,
                    upload: 0,
                    ping: 0,
                    jitter: 0,
                    loss: 0
                };
                this.init();
            }

            async init() {
                this.setupEventListeners();
                await this.checkServerStatus();
                await this.getClientIP();
                this.handleURLParams();
            }

            setupEventListeners() {
                document.getElementById('testServer').addEventListener('change', (e) => {
                    const customDiv = document.getElementById('customServerDiv');
                    customDiv.style.display = e.target.value === 'custom' ? 'block' : 'none';
                });
            }

            async checkServerStatus() {
                try {
                    const response = await fetch(`${this.serverUrl}/info`);
                    if (response.ok) {
                        const info = await response.json();
                        document.getElementById('serverLocation').textContent = info.server;
                        document.getElementById('serverStatus').textContent = 'Online';
                    }
                } catch (error) {
                    document.getElementById('serverStatus').textContent = 'Error';
                    console.error('Server status check failed:', error);
                }
            }

            async getClientIP() {
                try {
                    const response = await fetch(`${this.serverUrl}/ip`);
                    const data = await response.json();
                    document.getElementById('clientIP').textContent = data.ip;
                } catch (error) {
                    document.getElementById('clientIP').textContent = 'Unknown';
                }
            }

            getSelectedServer() {
                const serverSelect = document.getElementById('testServer');
                const customServer = document.getElementById('customServer');
                
                if (serverSelect.value === 'custom' && customServer.value) {
                    return customServer.value;
                }
                
                return this.serverUrl;
            }

            updateUI(phase, speed = 0, progress = 0) {
                const speedDisplay = document.getElementById('speedDisplay');
                const testType = document.getElementById('testType');
                const progressFill = document.getElementById('progressFill');
                const progressText = document.getElementById('progressText');
                const status = document.getElementById('status');

                speedDisplay.innerHTML = `${speed.toFixed(2)} <span class="unit">Mbps</span>`;
                testType.textContent = phase;
                progressFill.style.width = `${progress}%`;
                progressText.textContent = `${progress.toFixed(1)}% complete`;
                
                if (this.isRunning) {
                    testType.classList.add('testing');
                    status.textContent = `Testing ${phase.toLowerCase()}...`;
                } else {
                    testType.classList.remove('testing');
                }
            }

            async measurePing(serverUrl, samples = 8) {
                const pings = [];

                for (let i = 0; i < samples; i++) {
                    try {
                        const pingStart = performance.now();
                        await fetch(`${serverUrl}/ping?t=${Date.now()}&i=${i}`, { 
                            method: 'GET',
                            cache: 'no-cache',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                            }
                        });
                        const pingEnd = performance.now();
                        pings.push(pingEnd - pingStart);
                    } catch (error) {
                        console.warn('Ping sample failed:', error);
                    }
                    
                    const progress = ((i + 1) / samples) * 100;
                    this.updateUI('Measuring Ping', 0, progress);
                    
                    await new Promise(resolve => setTimeout(resolve, 150));
                }

                if (pings.length === 0) return { ping: 0, jitter: 0, loss: 100 };

                const avgPing = pings.reduce((a, b) => a + b, 0) / pings.length;
                const jitter = Math.sqrt(pings.reduce((sum, ping) => sum + Math.pow(ping - avgPing, 2), 0) / pings.length);
                const loss = ((samples - pings.length) / samples) * 100;

                return { ping: avgPing, jitter, loss };
            }

            async measureDownload(serverUrl, duration = 15) {
                const testData = [];
                const startTime = Date.now();
                const endTime = startTime + (duration * 1000);
                
                const connections = parseInt(document.getElementById('connectionCount').value);
                const promises = [];

                for (let i = 0; i < connections; i++) {
                    promises.push(this.downloadWorker(serverUrl, endTime, testData, i));
                }

                await Promise.all(promises);

                const totalBytes = testData.reduce((sum, bytes) => sum + bytes, 0);
                const totalTime = (Date.now() - startTime) / 1000;
                const speedMbps = (totalBytes * 8) / (totalTime * 1000000);

                return Math.max(speedMbps, 0);
            }

            async downloadWorker(serverUrl, endTime, testData, workerId) {
                const fileSizes = [5000000, 10000000, 25000000]; // 5MB, 10MB, 25MB
                let sizeIndex = workerId % fileSizes.length;

                while (Date.now() < endTime) {
                    try {
                        const size = fileSizes[sizeIndex];
                        const startTime = Date.now();
                        const response = await fetch(`${serverUrl}/download?size=${size}&worker=${workerId}&t=${Date.now()}`, {
                            cache: 'no-cache',
                            headers: {
                                'Cache-Control': 'no-cache, no-store, must-revalidate'
                            }
                        });
                        
                        if (response.ok) {
                            const reader = response.body.getReader();
                            let totalBytes = 0;

                            while (true) {
                                const { done, value } = await reader.read();
                                if (done) break;
                                totalBytes += value.length;
                                
                                if (Date.now() >= endTime) break;
                            }

                            testData.push(totalBytes);
                            
                            const elapsed = Date.now() - (endTime - 15000);
                            const progress = Math.min((elapsed / 15000) * 100, 100);
                            const currentSpeed = (totalBytes * 8) / ((Date.now() - startTime) / 1000) / 1000000;
                            this.updateUI('Download Test', currentSpeed, progress);
                        }
                        
                        sizeIndex = (sizeIndex + 1) % fileSizes.length;
                    } catch (error) {
                        console.warn('Download worker error:', error);
                        break;
                    }
                }
            }

            async measureUpload(serverUrl, duration = 15) {
                const testResults = [];
                const startTime = Date.now();
                const endTime = startTime + (duration * 1000);

                const payloadSizes = [1000000, 2000000, 5000000]; // 1MB, 2MB, 5MB
                let sizeIndex = 0;

                while (Date.now() < endTime) {
                    try {
                        const payloadSize = payloadSizes[sizeIndex % payloadSizes.length];
                        const uploadData = this.generateRandomData(payloadSize);
                        
                        const chunkStart = Date.now();
                        const response = await fetch(`${serverUrl}/upload`, {
                            method: 'POST',
                            body: uploadData,
                            headers: {
                                'Content-Type': 'application/octet-stream',
                                'Cache-Control': 'no-cache',
                                'Content-Length': payloadSize.toString()
                            },
                            cache: 'no-cache'
                        });

                        if (response.ok) {
                            const uploadTime = (Date.now() - chunkStart) / 1000;
                            const speedMbps = (payloadSize * 8) / (uploadTime * 1000000);
                            testResults.push(speedMbps);

                            const elapsed = Date.now() - startTime;
                            const progress = Math.min((elapsed / (duration * 1000)) * 100, 100);
                            this.updateUI('Upload Test', speedMbps, progress);
                        }
                        
                        sizeIndex++;
                    } catch (error) {
                        console.warn('Upload test error:', error);
                        break;
                    }
                }

                return testResults.length > 0 ? 
                    testResults.reduce((a, b) => a + b, 0) / testResults.length : 0;
            }

            generateRandomData(size) {
                const buffer = new ArrayBuffer(size);
                const view = new Uint8Array(buffer);
                
                for (let i = 0; i < size; i++) {
                    view[i] = Math.floor(Math.random() * 256);
                }
                
                return buffer;
            }

            async runTest() {
                if (this.isRunning) return;

                this.isRunning = true;
                const startBtn = document.getElementById('startBtn');
                const results = document.getElementById('results');
                
                startBtn.disabled = true;
                startBtn.textContent = 'TESTING...';
                results.classList.remove('show');

                const serverUrl = this.getSelectedServer();
                const duration = parseInt(document.getElementById('testDuration').value);

                try {
                    // Phase 1: Ping Test
                    const pingResults = await this.measurePing(serverUrl);
                    this.results.ping = pingResults.ping;
                    this.results.jitter = pingResults.jitter;
                    this.results.loss = pingResults.loss;

                    document.getElementById('pingValue').textContent = `${pingResults.ping.toFixed(0)}ms`;
                    document.getElementById('jitterValue').textContent = `${pingResults.jitter.toFixed(1)}ms`;
                    document.getElementById('lossValue').textContent = `${pingResults.loss.toFixed(1)}%`;

                    // Phase 2: Download Test
                    this.results.download = await this.measureDownload(serverUrl, duration);

                    // Phase 3: Upload Test
                    this.results.upload = await this.measureUpload(serverUrl, duration);

                    // Show results
                    this.showResults();

                } catch (error) {
                    console.error('Test failed:', error);
                    document.getElementById('status').innerHTML = `<div class="error">Test failed: ${error.message}</div>`;
                } finally {
                    this.isRunning = false;
                    startBtn.disabled = false;
                    startBtn.textContent = 'START TEST';
                    this.updateUI('Test Complete', Math.max(this.results.download, this.results.upload), 100);
                }
            }

            showResults() {
                const results = document.getElementById('results');
                document.getElementById('downloadResult').textContent = `${this.results.download.toFixed(2)} Mbps`;
                document.getElementById('uploadResult').textContent = `${this.results.upload.toFixed(2)} Mbps`;
                document.getElementById('durationResult').textContent = `${document.getElementById('testDuration').value} seconds`;
                document.getElementById('serverResult').textContent = new URL(this.getSelectedServer()).hostname;
                
                results.classList.add('show');

                // Update main display with the maximum speed achieved
                const maxSpeed = Math.max(this.results.download, this.results.upload);
                this.updateUI('Test Complete', maxSpeed, 100);
                
                // Update status
                document.getElementById('status').textContent = 'Test completed successfully!';
            }

            handleURLParams() {
                const params = new URLSearchParams(window.location.search);
                
                // Auto-run test
                if (params.has('run') || params.has('r')) {
                    const delay = parseInt(params.get('run') || params.get('r') || '0');
                    setTimeout(() => this.runTest(), delay * 1000);
                }
                
                // Set duration
                if (params.has('duration') || params.has('d')) {
                    const duration = params.get('duration') || params.get('d');
                    const durationSelect = document.getElementById('testDuration');
                    if ([10, 15, 30].includes(parseInt(duration))) {
                        durationSelect.value = duration;
                    }
                }
                
                // Set custom server
                if (params.has('server') || params.has('s')) {
                    const server = params.get('server') || params.get('s');
                    const serverSelect = document.getElementById('testServer');
                    if (server.startsWith('http')) {
                        serverSelect.value = 'custom';
                        document.getElementById('customServer').value = server;
                        document.getElementById('customServerDiv').style.display = 'block';
                    }
                }
                
                // Set connection count
                if (params.has('connections') || params.has('c')) {
                    const connections = params.get('connections') || params.get('c');
                    const connectionSelect = document.getElementById('connectionCount');
                    if ([4, 6, 8].includes(parseInt(connections))) {
                        connectionSelect.value = connections;
                    }
                }
            }
        }

        // Initialize the speed test
        const speedTest = new RailwaySpeedTest();

        function startTest() {
            speedTest.runTest();
        }

        // Handle page load
        window.addEventListener('load', () => {
            console.log('Railway Speed Test loaded');
        });
    </script>
</body>
</html>
